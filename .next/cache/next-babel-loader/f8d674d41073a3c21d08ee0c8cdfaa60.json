{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nvar _class,\n    _temp,\n    _jsxFileName = \"/Users/xxinyi/code/Next/Portfolio with Next/Xinyi-Next/node_modules/industry-ui/components/molecules/webcam/components/webcam.js\";\n\nvar __jsx = React.createElement;\n\n/**\n * Webcam\n */\n// React\nimport React, { Component } from 'react';\nimport { bool, func, number, object, oneOf, oneOfType, string } from 'prop-types'; // UI\n\nimport { Design } from \"./design\"; // Style\n\nimport { withTheme } from 'styled-components';\nconst Webcam = withTheme((_temp = _class = class Webcam extends Component {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"hasGetUserMedia\", () => {\n      return !!(navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);\n    });\n\n    _defineProperty(this, \"handleUserMedia\", (err, stream) => {\n      const {\n        onUserMediaError,\n        onUserMedia\n      } = this.props;\n\n      if (err) {\n        this.setState({\n          hasUserMedia: false\n        });\n        onUserMediaError(err);\n        return;\n      }\n\n      this.stream = stream;\n\n      try {\n        this.video.srcObject = stream;\n        this.setState({\n          hasUserMedia: true\n        });\n      } catch (error) {\n        this.setState({\n          hasUserMedia: true,\n          src: window.URL.createObjectURL(stream)\n        });\n      }\n\n      onUserMedia();\n    });\n\n    this.state = {\n      hasUserMedia: false,\n      src: ''\n    };\n  }\n\n  componentDidMount() {\n    if (!this.hasGetUserMedia()) return;\n    const {\n      hasUserMedia\n    } = this.state;\n    Webcam.mountedInstances.push(this);\n\n    if (!hasUserMedia && !Webcam.userMediaRequested) {\n      this.requestUserMedia();\n    }\n  }\n\n  componentWillUpdate(nextProps) {\n    const {\n      audioConstraints,\n      videoConstraints\n    } = this.props;\n\n    if (_JSON$stringify(nextProps.audioConstraints) !== _JSON$stringify(audioConstraints) || _JSON$stringify(nextProps.videoConstraints) !== _JSON$stringify(videoConstraints)) {\n      this.requestUserMedia();\n    }\n  }\n\n  componentWillUnmount() {\n    const {\n      src\n    } = this.state;\n    const index = Webcam.mountedInstances.indexOf(this);\n    Webcam.mountedInstances.splice(index, 1);\n\n    if (Webcam.mountedInstances.length === 0 && this.state.hasUserMedia) {\n      if (this.stream.stop) {\n        this.stream.stop();\n      } else {\n        if (this.stream.getVideoTracks) {\n          this.stream.getVideoTracks().map(track => track.stop());\n        }\n\n        if (this.stream.getAudioTracks) {\n          this.stream.getAudioTracks().map(track => track.stop());\n        }\n      }\n\n      Webcam.userMediaRequested = false;\n      window.URL.revokeObjectURL(src);\n    }\n  }\n\n  getScreenshot() {\n    const {\n      screenshotFormat,\n      screenshotQuality\n    } = this.props;\n    const {\n      hasUserMedia\n    } = this.state;\n    if (!hasUserMedia) return null;\n    const canvas = this.getCanvas();\n    return canvas && canvas.toDataURL(screenshotFormat, screenshotQuality);\n  }\n\n  getCanvas() {\n    const {\n      screenshotWidth\n    } = this.props;\n    const {\n      hasUserMedia\n    } = this.state;\n    const {\n      clientWidth,\n      videoHeight,\n      videoWidth\n    } = this.video;\n    if (!hasUserMedia || !videoHeight) return null;\n\n    if (!this.ctx) {\n      const canvas = document.createElement('canvas');\n      const aspectRatio = videoWidth / videoHeight;\n      const canvasWidth = screenshotWidth || clientWidth;\n      canvas.width = canvasWidth;\n      canvas.height = canvasWidth / aspectRatio;\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n    }\n\n    const {\n      ctx,\n      canvas\n    } = this;\n    ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);\n    return canvas;\n  }\n\n  requestUserMedia() {\n    const {\n      audio,\n      audioConstraints,\n      videoConstraints\n    } = this.props;\n    navigator.getUserMedia = navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\n    const sourceSelected = (audioConstraints, videoConstraints) => {\n      // Request video\n      const constraints = {\n        video: videoConstraints || true\n      }; // Request Audo\n\n      if (audio) {\n        constraints.audio = audioConstraints || true;\n      }\n\n      navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n        Webcam.mountedInstances.forEach(() => this.handleUserMedia(null, stream));\n      }).catch(e => {\n        Webcam.mountedInstances.forEach(() => this.handleUserMedia(e));\n      });\n    };\n\n    if ('mediaDevices' in navigator) {\n      sourceSelected(audioConstraints, videoConstraints);\n    } else {\n      const optionalSource = id => ({\n        optional: [{\n          sourceId: id\n        }]\n      });\n\n      const constraintToSourceId = constraint => {\n        const deviceId = (constraint || {}).deviceId;\n\n        if (typeof deviceId === 'string') {\n          return deviceId;\n        } else if (_Array$isArray(deviceId) && deviceId.length > 0) {\n          return deviceId[0];\n        } else if (typeof deviceId === 'object' && deviceId.ideal) {\n          return deviceId.ideal;\n        }\n\n        return null;\n      };\n\n      window.MediaStreamTrack.getSources(sources => {\n        let audioSource = null;\n        let videoSource = null;\n        sources.forEach(source => {\n          if (source.kind === 'audio') {\n            audioSource = source.id;\n          } else if (source.kind === 'video') {\n            videoSource = source.id;\n          }\n        });\n        const audioSourceId = constraintToSourceId(audioConstraints);\n\n        if (audioSourceId) {\n          audioSource = audioSourceId;\n        }\n\n        const videoSourceId = constraintToSourceId(videoConstraints);\n\n        if (videoSourceId) {\n          videoSource = videoSourceId;\n        }\n\n        sourceSelected(optionalSource(audioSource), optionalSource(videoSource));\n      });\n    }\n\n    Webcam.userMediaRequested = true;\n  }\n\n  render() {\n    const {\n      audio,\n      className,\n      height,\n      style,\n      width\n    } = this.props;\n    const {\n      src\n    } = this.state;\n    return __jsx(\"video\", {\n      autoPlay: true,\n      width: width,\n      height: height,\n      src: src,\n      muted: audio,\n      className: className,\n      playsInline: true,\n      style: style,\n      ref: ref => {\n        this.video = ref;\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254\n      },\n      __self: this\n    });\n  }\n\n}, _defineProperty(_class, \"propTypes\", {\n  audio: bool,\n  onUserMedia: func,\n  onUserMediaError: func,\n  height: oneOfType([number, string]),\n  width: oneOfType([number, string]),\n  screenshotFormat: oneOf(['image/webp', 'image/png', 'image/jpeg']),\n  style: object,\n  className: string,\n  screenshotQuality: number,\n  screenshotWidth: number // audioConstraints: audioConstraintType,\n  // videoConstraints: videoConstraintType\n\n}), _defineProperty(_class, \"defaultProps\", {\n  audio: false,\n  className: '',\n  height: 463.5,\n  onUserMedia: () => {},\n  onUserMediaError: () => {},\n  screenshotFormat: 'image/webp',\n  screenshotQuality: 0.8,\n  style: {\n    borderRadius: '.5rem .5rem 0 0'\n  },\n  width: 824\n}), _defineProperty(_class, \"mountedInstances\", []), _defineProperty(_class, \"userMediaRequested\", false), _temp));\nWebcam.Design = Design;\nexport { Webcam }; // const constrainStringType = PropTypes.oneOfType([\n//   PropTypes.string,\n//   PropTypes.arrayOf(PropTypes.string),\n//   PropTypes.shape({\n//     exact: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n// ]);\n// const constrainBooleanType = PropTypes.oneOfType([\n//   PropTypes.shape({\n//     exact: PropTypes.bool,\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.bool,\n//   }),\n// ]);\n// const constrainLongType = PropTypes.oneOfType([\n//   PropTypes.number,\n//   PropTypes.shape({\n//     exact: PropTypes.number,\n//     ideal: PropTypes.number,\n//     min: PropTypes.number,\n//     max: PropTypes.number,\n//   }),\n// ]);\n// const constrainDoubleType = constrainLongType;\n// const audioConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   autoGainControl: constrainBooleanType,\n//   channelCount: constrainLongType,\n//   latency: constrainDoubleType,\n//   noiseSuppression: constrainBooleanType,\n//   sampleRate: constrainLongType,\n//   sampleSize: constrainLongType,\n//   volume: constrainDoubleType,\n// });\n// const videoConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   aspectRatio: constrainDoubleType,\n//   facingMode: constrainStringType,\n//   frameRate: constrainDoubleType,\n//   height: constrainLongType,\n//   width: constrainLongType,\n// });","map":{"version":3,"sources":["/Users/xxinyi/code/Next/Portfolio with Next/Xinyi-Next/node_modules/industry-ui/components/molecules/webcam/components/webcam.js"],"names":["React","Component","bool","func","number","object","oneOf","oneOfType","string","Design","withTheme","Webcam","constructor","navigator","mediaDevices","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","err","stream","onUserMediaError","onUserMedia","props","setState","hasUserMedia","video","srcObject","error","src","window","URL","createObjectURL","state","componentDidMount","hasGetUserMedia","mountedInstances","push","userMediaRequested","requestUserMedia","componentWillUpdate","nextProps","audioConstraints","videoConstraints","componentWillUnmount","index","indexOf","splice","length","stop","getVideoTracks","map","track","getAudioTracks","revokeObjectURL","getScreenshot","screenshotFormat","screenshotQuality","canvas","getCanvas","toDataURL","screenshotWidth","clientWidth","videoHeight","videoWidth","ctx","document","createElement","aspectRatio","canvasWidth","width","height","getContext","drawImage","audio","sourceSelected","constraints","then","forEach","handleUserMedia","catch","e","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","ideal","MediaStreamTrack","getSources","sources","audioSource","videoSource","source","kind","audioSourceId","videoSourceId","render","className","style","ref","borderRadius"],"mappings":"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","sourcesContent":["/**\n * Webcam\n */\n\n// React\nimport React, { Component } from 'react'\nimport { bool, func, number, object, oneOf, oneOfType, string } from 'prop-types'\n\n// UI\nimport { Design } from './design'\n\n// Style\nimport { withTheme } from 'styled-components'\n\nconst Webcam = withTheme(\n  class Webcam extends Component {\n    constructor () {\n      super()\n      this.state = {\n        hasUserMedia: false,\n        src: ''\n      }\n    }\n\n    static propTypes = {\n      audio: bool,\n      onUserMedia: func,\n      onUserMediaError: func,\n      height: oneOfType([number, string]),\n      width: oneOfType([number, string]),\n      screenshotFormat: oneOf(['image/webp', 'image/png', 'image/jpeg']),\n      style: object,\n      className: string,\n      screenshotQuality: number,\n      screenshotWidth: number\n      // audioConstraints: audioConstraintType,\n      // videoConstraints: videoConstraintType\n    }\n\n    static defaultProps = {\n      audio: false,\n      className: '',\n      height: 463.5,\n      onUserMedia: () => {},\n      onUserMediaError: () => {},\n      screenshotFormat: 'image/webp',\n      screenshotQuality: 0.8,\n      style: { borderRadius: '.5rem .5rem 0 0' },\n      width: 824\n    }\n\n    static mountedInstances = []\n\n    static userMediaRequested = false\n\n    componentDidMount () {\n      if (!this.hasGetUserMedia()) return\n\n      const { hasUserMedia } = this.state\n\n      Webcam.mountedInstances.push(this)\n\n      if (!hasUserMedia && !Webcam.userMediaRequested) {\n        this.requestUserMedia()\n      }\n    }\n\n    componentWillUpdate (nextProps) {\n      const { audioConstraints, videoConstraints } = this.props\n\n      if (\n        JSON.stringify(nextProps.audioConstraints) !== JSON.stringify(audioConstraints) ||\n        JSON.stringify(nextProps.videoConstraints) !== JSON.stringify(videoConstraints)\n      ) {\n        this.requestUserMedia()\n      }\n    }\n\n    componentWillUnmount () {\n      const { src } = this.state\n\n      const index = Webcam.mountedInstances.indexOf(this)\n      Webcam.mountedInstances.splice(index, 1)\n\n      if (Webcam.mountedInstances.length === 0 && this.state.hasUserMedia) {\n        if (this.stream.stop) {\n          this.stream.stop()\n        } else {\n          if (this.stream.getVideoTracks) {\n            this.stream.getVideoTracks().map(track => track.stop())\n          }\n          if (this.stream.getAudioTracks) {\n            this.stream.getAudioTracks().map(track => track.stop())\n          }\n        }\n        Webcam.userMediaRequested = false\n        window.URL.revokeObjectURL(src)\n      }\n    }\n\n    hasGetUserMedia = () => {\n      return !!(\n        navigator.mediaDevices.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia ||\n        navigator.msGetUserMedia\n      )\n    }\n\n    getScreenshot () {\n      const { screenshotFormat, screenshotQuality } = this.props\n      const { hasUserMedia } = this.state\n\n      if (!hasUserMedia) return null\n\n      const canvas = this.getCanvas()\n\n      return canvas && canvas.toDataURL(screenshotFormat, screenshotQuality)\n    }\n\n    getCanvas () {\n      const { screenshotWidth } = this.props\n      const { hasUserMedia } = this.state\n      const { clientWidth, videoHeight, videoWidth } = this.video\n\n      if (!hasUserMedia || !videoHeight) return null\n\n      if (!this.ctx) {\n        const canvas = document.createElement('canvas')\n        const aspectRatio = videoWidth / videoHeight\n\n        const canvasWidth = screenshotWidth || clientWidth\n\n        canvas.width = canvasWidth\n        canvas.height = canvasWidth / aspectRatio\n\n        this.canvas = canvas\n        this.ctx = canvas.getContext('2d')\n      }\n\n      const { ctx, canvas } = this\n      ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height)\n\n      return canvas\n    }\n\n    requestUserMedia () {\n      const { audio, audioConstraints, videoConstraints } = this.props\n\n      navigator.getUserMedia =\n        navigator.mediaDevices.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia ||\n        navigator.msGetUserMedia\n\n      const sourceSelected = (audioConstraints, videoConstraints) => {\n        // Request video\n        const constraints = {\n          video: videoConstraints || true\n        }\n\n        // Request Audo\n        if (audio) {\n          constraints.audio = audioConstraints || true\n        }\n\n        navigator.mediaDevices\n          .getUserMedia(constraints)\n          .then(stream => {\n            Webcam.mountedInstances.forEach(() => this.handleUserMedia(null, stream))\n          })\n          .catch(e => {\n            Webcam.mountedInstances.forEach(() => this.handleUserMedia(e))\n          })\n      }\n\n      if ('mediaDevices' in navigator) {\n        sourceSelected(audioConstraints, videoConstraints)\n      } else {\n        const optionalSource = id => ({ optional: [{ sourceId: id }] })\n\n        const constraintToSourceId = constraint => {\n          const deviceId = (constraint || {}).deviceId\n\n          if (typeof deviceId === 'string') {\n            return deviceId\n          } else if (Array.isArray(deviceId) && deviceId.length > 0) {\n            return deviceId[0]\n          } else if (typeof deviceId === 'object' && deviceId.ideal) {\n            return deviceId.ideal\n          }\n\n          return null\n        }\n\n        window.MediaStreamTrack.getSources(sources => {\n          let audioSource = null\n          let videoSource = null\n\n          sources.forEach(source => {\n            if (source.kind === 'audio') {\n              audioSource = source.id\n            } else if (source.kind === 'video') {\n              videoSource = source.id\n            }\n          })\n\n          const audioSourceId = constraintToSourceId(audioConstraints)\n          if (audioSourceId) {\n            audioSource = audioSourceId\n          }\n\n          const videoSourceId = constraintToSourceId(videoConstraints)\n          if (videoSourceId) {\n            videoSource = videoSourceId\n          }\n\n          sourceSelected(optionalSource(audioSource), optionalSource(videoSource))\n        })\n      }\n\n      Webcam.userMediaRequested = true\n    }\n\n    handleUserMedia = (err, stream) => {\n      const { onUserMediaError, onUserMedia } = this.props\n\n      if (err) {\n        this.setState({ hasUserMedia: false })\n        onUserMediaError(err)\n        return\n      }\n\n      this.stream = stream\n\n      try {\n        this.video.srcObject = stream\n        this.setState({ hasUserMedia: true })\n      } catch (error) {\n        this.setState({\n          hasUserMedia: true,\n          src: window.URL.createObjectURL(stream)\n        })\n      }\n\n      onUserMedia()\n    }\n\n    render () {\n      const { audio, className, height, style, width } = this.props\n      const { src } = this.state\n\n      return (\n        <video\n          autoPlay\n          width={width}\n          height={height}\n          src={src}\n          muted={audio}\n          className={className}\n          playsInline\n          style={style}\n          ref={ref => {\n            this.video = ref\n          }}\n        />\n      )\n    }\n  }\n)\n\nWebcam.Design = Design\n\nexport { Webcam }\n\n// const constrainStringType = PropTypes.oneOfType([\n//   PropTypes.string,\n//   PropTypes.arrayOf(PropTypes.string),\n//   PropTypes.shape({\n//     exact: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.oneOfType([\n//       PropTypes.string,\n//       PropTypes.arrayOf(PropTypes.string),\n//     ]),\n//   }),\n// ]);\n\n// const constrainBooleanType = PropTypes.oneOfType([\n//   PropTypes.shape({\n//     exact: PropTypes.bool,\n//   }),\n//   PropTypes.shape({\n//     ideal: PropTypes.bool,\n//   }),\n// ]);\n\n// const constrainLongType = PropTypes.oneOfType([\n//   PropTypes.number,\n//   PropTypes.shape({\n//     exact: PropTypes.number,\n//     ideal: PropTypes.number,\n//     min: PropTypes.number,\n//     max: PropTypes.number,\n//   }),\n// ]);\n\n// const constrainDoubleType = constrainLongType;\n\n// const audioConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   autoGainControl: constrainBooleanType,\n//   channelCount: constrainLongType,\n//   latency: constrainDoubleType,\n//   noiseSuppression: constrainBooleanType,\n//   sampleRate: constrainLongType,\n//   sampleSize: constrainLongType,\n//   volume: constrainDoubleType,\n// });\n\n// const videoConstraintType = PropTypes.shape({\n//   deviceId: constrainStringType,\n//   groupId: constrainStringType,\n//   aspectRatio: constrainDoubleType,\n//   facingMode: constrainStringType,\n//   frameRate: constrainDoubleType,\n//   height: constrainLongType,\n//   width: constrainLongType,\n// });\n"]},"metadata":{},"sourceType":"module"}